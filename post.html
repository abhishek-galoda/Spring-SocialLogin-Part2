<h2>Part-2: Authorising user using Spring Social (Google, FaceBook and LinkedIn) and Spring Security</h2>
<h3>Introduction</h3>
In the last part, I had demonstrated how we can use spring-social to authorize user using Facebook, Google and LinkedIn API's. If you have not read the last part, I would request you to have a look and then come back to this part.

In this part, I am going to use spring security to allow only logged in users or authenticated users to navigate to secure pages, any user attempting to go to secure pages will be redirected to the Login page for authentication.
Once the user is authenticated, we will save his details to in-memory DB and then the user can log out and log in again.

Spring Security framework provides both authentication and authorization feature for applications. It also helps in preventing attacks like session fixation, clickjacking, cross-site request forgery, etc and good thing is that it can be customized easily to fit in different use cases.
In this tutorial, we will add spring security with spring social API to register users and then add the log on and log out functionality.
<h3>Step 1 - Adding Maven dependencies</h3>
The first step to start will be adding maven dependencies for Spring-security and also for thymeleaf-extras-spring security for using spring-security tags for displaying logged in user and roles etc on pages.
Add the following dependencies to the POM.xml
<pre class="lang:xhtml decode:true">	
      	&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
			&lt;artifactId&gt;spring-security-web&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
			&lt;artifactId&gt;spring-security-config&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
      	    &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;
        &lt;artifactId&gt;thymeleaf-extras-springsecurity4&lt;/artifactId&gt;
   	    &lt;/dependency&gt;
</pre>
<h3>Step 2 - Registering user on site</h3>
When logging on to social networking platforms, we didn't need any form as we fetch the user details through the API. However, to register a user we will need a simple form to capture their details. We will create a view called registration.html under src/main/resources/templates/registration.html.
This form will have server-side validation and minimal CSS/JS
<img class="aligncenter size-full wp-image-1214" src="http://littlebigextra.com/wp-content/uploads/2017/11/Registration.jpg" alt="" width="260" height="294" />Source code of Registration page is below
<pre class="lang:xhtml decode:true">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="utf-8" /&gt;
&lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;
&lt;title&gt;Login&lt;/title&gt;
&lt;meta name="description" content="" /&gt;
&lt;meta name="viewport" content="width=device-width" /&gt;
&lt;base href="/" /&gt;
&lt;link rel="stylesheet" type="text/css" href="/webjars/bootstrap/css/bootstrap.min.css" /&gt;
&lt;script type="text/javascript" src="/webjars/jquery/jquery.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/webjars/bootstrap/js/bootstrap.min.js"&gt;&lt;/script&gt;
&lt;link rel="stylesheet" href="/webjars/font-awesome/css/font-awesome.min.css"&gt;&lt;/link&gt;
&lt;/head&gt;

&lt;body&gt;
	&lt;div class="container" style="width:80%"&gt;
	&lt;h1&gt;Registration Page&lt;/h1&gt;
	&lt;br /&gt;
		&lt;form action="#" th:action="@{/registration}" th:object="${userBean}" method="post" &gt;
			&lt;div class="form-group" &gt;
				&lt;label for="email" class="control-label col-sm-2"&gt;Email*&lt;/label&gt;:: &lt;input type="text" th:field="*{email}"  placeholder="Enter email"/&gt;
				&lt;div style="width:33%"  th:if="${#fields.hasErrors('email')}" th:errors="*{email}" class="alert alert-danger"&gt;Email Error&lt;/div&gt;
			&lt;/div&gt;
			&lt;div class="form-group"&gt;
				&lt;label for="firstName" class="control-label col-sm-2"&gt;First Name*&lt;/label&gt;:: &lt;input type="text" th:field="*{firstName}" /&gt;
				&lt;div style="width:33%" th:if="${#fields.hasErrors('firstName')}" th:errors="*{firstName}" class="alert alert-danger"&gt;FirstName Error&lt;/div&gt;
			&lt;/div&gt;
			&lt;div class="form-group"&gt;
				&lt;label for="lastName" class="control-label col-sm-2"&gt;Last Name*&lt;/label&gt;:: &lt;input type="text" th:field="*{lastName}" /&gt;
				&lt;div style="width:33%" th:if="${#fields.hasErrors('lastName')}" th:errors="*{lastName}" class="alert alert-danger"&gt;LastName Error&lt;/div&gt;
			&lt;/div&gt;
			&lt;div class="form-group"&gt;
				&lt;label for="password" class="control-label col-sm-2"&gt;Password*&lt;/label&gt;:: &lt;input type="text" th:field="*{password}" /&gt;
				&lt;div style="width:33%" th:if="${#fields.hasErrors('password')}" th:errors="*{password}" class="alert alert-danger"&gt;Password Error&lt;/div&gt;
			&lt;/div&gt;
			&lt;div class="form-group"&gt;
				&lt;label for="passwordConfirm" class="control-label col-sm-2"&gt;Confirm Password*&lt;/label&gt;:: &lt;input type="text" th:field="*{passwordConfirm}" /&gt;
				&lt;div style="width:33%" th:if="${#fields.hasErrors('passwordConfirm')}" th:errors="*{passwordConfirm}" class="alert alert-danger"&gt;Password Error&lt;/div&gt;
			&lt;/div&gt;
			&lt;div class="form-group"&gt;
				&lt;label for="title" class="control-label col-sm-2"&gt;Title&lt;/label&gt;:: &lt;select th:field="*{title}"&gt;
					&lt;option value="Mr" th:text="Mr"&gt;&lt;/option&gt;
					&lt;option value="Mrs" th:text="Mrs"&gt;&lt;/option&gt;
				&lt;/select&gt;
				&lt;div th:if="${#fields.hasErrors('title')}" th:errors="*{title}"&gt;Title Error&lt;/div&gt;
			&lt;/div&gt;
			&lt;div class="form-group"&gt;
				&lt;label for="country" class="control-label col-sm-2"&gt;Country&lt;/label&gt;:: &lt;select th:field="*{country}"&gt;
					&lt;option value="India" th:text="India"&gt;&lt;/option&gt;
					&lt;option value="UK" th:text="UK"&gt;&lt;/option&gt;
					&lt;option value="US" th:text="US"&gt;&lt;/option&gt;
					&lt;option value="Japan" th:text="Japan"&gt;&lt;/option&gt;
				&lt;/select&gt;
				&lt;div th:if="${#fields.hasErrors('country')}" th:errors="*{country}" class="alert alert-danger"&gt;Country Error&lt;/div&gt;
			&lt;/div&gt;
			&lt;input type="hidden" name="provider"  value="registration" /&gt;
			&lt;div class="form-group"&gt;
				&lt;button type="submit" class="btn btn-primary"&gt;Register&lt;/button&gt;
			&lt;/div&gt;
		&lt;/form&gt;

	&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<h4>Modifying the Controller</h4>
To serve this Page, we will modify the existing Login controller
<pre class="lang:java decode:true">    @GetMapping("/registration")
    public String showRegistration(UserBean userBean) {
	return "registration";
    }</pre>
<h4>Modifying the Login Page</h4>
Now let's modify the login page and add the registration link on the home page, also we will add username and password fields so once the user is registered they can also log in.

This HTML fragment will add a username/password field along with an error message, in case of the user not found.

<form style="display: inline;" method="post">
<pre class="lang:xhtml decode:true">	&lt;form th:action="@{/login}" method="post" style="display: inline"&gt;
			&lt;label for="username"&gt;Username&lt;/label&gt;: &lt;input type="text" id="username" name="username" autofocus="autofocus" /&gt; &lt;br /&gt;
			&lt;label for="password"&gt;Password&lt;/label&gt;: &lt;input type="password" id="password" name="password" /&gt; &lt;br /&gt;
			&lt;p th:if="${loginError}" class="alert alert-danger"&gt;Wrong email or password combination&lt;/p&gt;
			&lt;button type="submit" class="btn btn-primary"&gt;
				&lt;span class="fa fa-user"&gt;&lt;/span&gt;Login
			&lt;/button&gt;
		&lt;/form&gt;</pre>
&nbsp;

</form>Also let's add another code fragment which is to display the Logged In user, the role assigned and a Logout button
<div class="logout">
<pre class="lang:java decode:true">		&lt;div th:fragment="logout" class="logout" sec:authorize="isAuthenticated()"&gt;
			Logged in user: &lt;b&gt;&lt;span sec:authentication="name"&gt;&lt;/span&gt;&lt;/b&gt; | Roles: &lt;b&gt;&lt;span sec:authentication="authorities"&gt;&lt;/span&gt;&lt;/b&gt;
				&lt;form action="#" th:action="@{/logout}" method="post"&gt;
			       &lt;button type="submit"  class="btn btn-danger btn-sm"
			       &lt;span class="glyphicon glyphicon-log-out"&gt;&lt;/span&gt;
			        Log out&lt;/button&gt;
				&lt;/form&gt;
		&lt;/div&gt;
</pre>
&nbsp;

</div>
We will also need to csrf token to our existing forms for Google, Facebook and LinkedIn
<pre class="lang:java decode:true">&lt;input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" /&gt;</pre>
This is how the Complete Login.html looks like.

<img class="aligncenter wp-image-1213 size-full" src="http://littlebigextra.com/wp-content/uploads/2017/11/Login-2.jpg" alt="Login Page" width="300" height="146" />
<pre class="lang:java decode:true" title="Login">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="utf-8" /&gt;
&lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;
&lt;title&gt;Login&lt;/title&gt;
&lt;meta name="description" content="" /&gt;
&lt;meta name="viewport" content="width=device-width" /&gt;
&lt;base href="/" /&gt;
&lt;link rel="stylesheet" type="text/css" href="/webjars/bootstrap/css/bootstrap.min.css" /&gt;
&lt;script type="text/javascript" src="/webjars/jquery/jquery.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/webjars/bootstrap/js/bootstrap.min.js"&gt;&lt;/script&gt;
&lt;link rel="stylesheet" href="/webjars/font-awesome/css/font-awesome.min.css"&gt;&lt;/link&gt;
&lt;/head&gt;

&lt;body&gt;

	&lt;div class="container"&gt;
		
		&lt;div th:fragment="logout" class="logout" sec:authorize="isAuthenticated()"&gt;
			Logged in user: &lt;b&gt;&lt;span sec:authentication="name"&gt;&lt;/span&gt;&lt;/b&gt; | Roles: &lt;b&gt;&lt;span sec:authentication="authorities"&gt;&lt;/span&gt;&lt;/b&gt;
				&lt;form action="#" th:action="@{/logout}" method="post"&gt;
			       &lt;button type="submit"  class="btn btn-danger btn-sm"&gt;
			       &lt;span class="glyphicon glyphicon-log-out"&gt;&lt;/span&gt;
			        Log out&lt;/button&gt;
				&lt;/form&gt;
		&lt;/div&gt;
		&lt;br/&gt;
		
		&lt;h1&gt;Login Using&lt;/h1&gt;

		&lt;form th:action="@{/login}" method="post" style="display: inline"&gt;
			&lt;label for="username"&gt;Email   &lt;/label&gt; : &lt;input type="text" id="username" name="username" autofocus="autofocus" placeholder="Enter email"/&gt; &lt;br /&gt;
			&lt;label for="password"&gt;Password&lt;/label&gt;: &lt;input type="password" id="password" name="password" /&gt; &lt;br /&gt;
			&lt;p th:if="${loginError}" class="alert alert-danger"&gt;Wrong email or password combination&lt;/p&gt;
			&lt;button type="submit" class="btn btn-primary"&gt;
				&lt;span class="fa fa-user"&gt;&lt;/span&gt;Login
			&lt;/button&gt;
		&lt;/form&gt;
		
		&lt;form action="/connect/google" method="POST" style="display: inline"&gt;
			&lt;input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" /&gt; 
			&lt;input type="hidden" name="scope" value="profile email" /&gt;
			&lt;button type="submit" class="btn btn-danger"&gt;
				Google &lt;span class="fa fa-google-plus"&gt;&lt;/span&gt;
			&lt;/button&gt;
		&lt;/form&gt;

		&lt;form action="/connect/facebook" method="POST" style="display: inline"&gt;
			&lt;input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" /&gt; 
			&lt;input type="hidden" name="scope" value="public_profile,email" /&gt;
			&lt;button type="submit" class="btn btn-primary"&gt;
				Facebook &lt;span class="fa fa-facebook"&gt;&lt;/span&gt;
			&lt;/button&gt;
		&lt;/form&gt;

		&lt;form action="/connect/linkedin" method="POST" style="display: inline"&gt;
		&lt;input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" /&gt; 
			&lt;input type="hidden" name="scope"
				value="r_basicprofile,r_emailaddress" /&gt;
			&lt;button type="submit" class="btn btn-primary"&gt;
				LinkedIn &lt;span class="fa fa-linkedin"&gt;&lt;/span&gt;
			&lt;/button&gt;
		&lt;/form&gt;
		&lt;br /&gt;
		&lt;h3&gt;
			&lt;p class="bg-important"&gt;
				&lt;a href="/registration" th:href="@{/registration}"&gt;Create Account&lt;/a&gt;
			&lt;/p&gt;
		&lt;/h3&gt;
	&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<h3>Step 3 - Saving User to Database</h3>
Once the user is authenticated, we will need to save their details in a database. So we will use the annotations like @Entity and @Table to create an in-memory database(HSQLDB) and tables if they don't exist. The DB details can be easily configured in application.properties,also the DB type can also be changed easily.
We will use the hibernate validator annotations @NotNull,@Size to make sure that input fields are validated on the server side before they can be, you can add client-side javascript if that suits.
<pre class="lang:java decode:true">package com.login.model;

import java.io.Serializable;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;
import javax.persistence.Transient;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

import org.hibernate.validator.constraints.Email;

@Entity(name = "user")
@Table(name = "user")
public class UserBean implements Serializable{
	
	private static final long serialVersionUID = 1L;
	
	@NotNull(message = "Email  cannot be empty")
	@Email(message = "Email Format is not valid")
	@Size(min = 3, max = 30, message = "Email can not be empty")
	@Id
	private String email;
	
	@NotNull(message = "First Name cannot be empty")
	@Size(min = 3, max = 30, message = "First Name cannot be less than 3 characters")
	private String firstName;

	@NotNull(message = "Last Name cannot be empty")
	@Size(min = 3, max = 30, message = "Last Name cannot be less than 3 characters")
	private String lastName;

	private String title;
	private String country;
	private String password;
	@Transient
	private String passwordConfirm;	
	private String provider;
	private String image;

	......getter/setter methods here ...

}
</pre>
<h4>Saving the Bean using JPA Repository</h4>
We will be using <a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/" rel="noopener">Spring Data</a> to retrieve user details and save them.
Now we will create a new interface called UserRepository in package com.login.repository this interface will extend the JPARespository&lt;T, ID&gt; where T is UserBean in our Case and ID is the email(primary key).
We will define the abstract method findByEmail by passing email which has been defined as a primary key in UserBean class. To get the UserBean for a particular method all we need to do is inject the UserRepository and call findByemail method()
<pre class="lang:java decode:true">package com.login.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import com.login.model.UserBean;

public interface UserRepository extends JpaRepository&lt;UserBean, String&gt; {

    	UserBean findByEmail(String email);

}

</pre>
The key advantage of using Spring Data is that it makes virtually our code DAO implementation-free, only above interface will be able to save and retrieve user details.
<h3>Step 4 - Adding the Spring Security</h3>
This is the crux of this tutorial, we will use the spring security to define which URL's can be accessed only by insecurely and which one can only be accessed by login user.

We will add a class called SecurityConfig to allow users to
<ul>
 	<li style="list-style-type: none;">
<ol>Allow URLs which start with CSS/** and /connect** to be accessed by all users</ol>
</li>
 	<li style="list-style-type: none;">
<ol>Allow /secure/* URL to be accessed only by logged in User</ol>
</li>
 	<li style="list-style-type: none;">
<ol>If any secure/* is accessed by unauthenticated user, redirect him to login page</ol>
</li>
 	<li style="list-style-type: none;">
<ol>In case of unsuccessful authentication, redirect user to /login-error</ol>
</li>
 	<li style="list-style-type: none;">
<ol>Add logout functionality</ol>
</li>
</ul>
<pre class="lang:java decode:true">package com.login.security;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

//@formatter:off
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

	@Autowired
	private UserDetailsService userDetailsService;

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.authorizeRequests().antMatchers("/css/**", "/connect/**").permitAll()
				.antMatchers("/secure/**")
				.authenticated()
				.and()
				.formLogin()
				.loginPage("/login")
				.defaultSuccessUrl("/secure/user")
				.failureUrl("/login-error")
				.permitAll()
				.and()
				.logout()
				.permitAll();
	}
	
	@Bean
	public BCryptPasswordEncoder bCryptPasswordEncoder() {
		return new BCryptPasswordEncoder();
	}
	
	@Autowired
	public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
		auth.userDetailsService(userDetailsService).passwordEncoder(bCryptPasswordEncoder());
	}

}

// @formatter:on</pre>
As you might have noticed that we have added a bean for BCryptPasswordEncoder, this bean will be used for encrypting the password as hash, which is one of the safest technique to store passwords and decrypting hash is very tough ( Maybe not as tough as mining a BitCoin :) )

Also, there is another method configureglobal(AuthenticationManagerBuilder auth) which basically defines that we have defined our own custom implementation of UserDetailsService, we will talk about it later.
<h4>Move user.html to secure/user.html</h4>
Since now we want our user.html to be only presented for logged in users we will move user.html from src/main/resources/templates to src/main/resources/templates/secure/user.html
Also, we will add the thymleaf authentication tags to display logged in Username and role.
This is how the complete user.html looks like, make sure it is in src/main/resources/templates/secure/user.html
<pre class="lang:xhtml decode:true">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="utf-8" /&gt;
&lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;
&lt;title&gt;Login&lt;/title&gt;
&lt;meta name="description" content="" /&gt;
&lt;meta name="viewport" content="width=device-width" /&gt;
&lt;meta name="ctx" th:content="${#httpServletRequest.getContextPath()}" /&gt;
&lt;base href="/" /&gt;
&lt;link rel="stylesheet" type="text/css" href="/webjars/bootstrap/css/bootstrap.min.css" /&gt;
&lt;script type="text/javascript" src="/webjars/jquery/jquery.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/webjars/bootstrap/js/bootstrap.min.js"&gt;&lt;/script&gt;
&lt;link rel="stylesheet" href="/webjars/font-awesome/css/font-awesome.min.css"&gt;&lt;/link&gt;
&lt;/head&gt;
&lt;body&gt;

	&lt;div class="container"&gt;
		&lt;h1&gt;Secure Page&lt;/h1&gt;
				&lt;div th:fragment="logout" class="logout" sec:authorize="isAuthenticated()"&gt;
			Logged in user: &lt;b&gt;&lt;span sec:authentication="name"&gt;&lt;/span&gt;&lt;/b&gt; | Roles: &lt;b&gt;&lt;span sec:authentication="authorities"&gt;&lt;/span&gt;&lt;/b&gt;
				&lt;form action="#" th:action="@{/logout}" method="post"&gt;
			       &lt;button type="submit"  class="btn btn-danger btn-sm"&gt;
			       &lt;span class="glyphicon glyphicon-log-out"&gt;&lt;/span&gt;
			        Log out&lt;/button&gt;
				&lt;/form&gt;
		&lt;/div&gt;

		&lt;br/&gt;
		&lt;form th:object="${loggedInUser}" method="post"&gt;
			&lt;div class="row"&gt;
				&lt;label for="email"&gt;Email :&lt;/label&gt;
				&lt;span th:text="*{email}" /&gt;
			&lt;/div&gt;
			&lt;div class="row"&gt;
				&lt;label for="firstName"&gt;Name:&lt;/label&gt;
				 &lt;span th:text="*{firstName}" /&gt; &lt;span th:text="*{lastName}" /&gt;
			&lt;/div&gt;
			&lt;div class="row"&gt;
				&lt;label for="image"&gt;Image:&lt;/label&gt;
				 &lt;img th:attr="src=@{*{image}}" style="width: 150px; height: 150px;"/&gt;
			&lt;/div&gt;

		&lt;/form&gt;
		&lt;br /&gt;
		  &lt;a href="/login" th:href="@{/login}" class="btn btn-info btn-lg"&gt;
          &lt;span class="glyphicon glyphicon-chevron-left"&gt;&lt;/span&gt; Login using  other social Providers
         &lt;/a&gt;
		 
	&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;</pre>
<h3>Step 6 - Adding UserDetails service, our own implementation</h3>
This is the crucial step as would define here what to do when the user puts in his username/password combination.
If we want user authentication by a DAO class, we need to implement the UserDetailsService interface. This interface has loadUserByUsername() method which is used to validate the user, of course, we need to provide the implementation.

Remeber this method in Security config
<pre class="lang:java decode:true">	@Autowired
	public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
		auth.userDetailsService(userDetailsService).passwordEncoder(bCryptPasswordEncoder());
	}
</pre>
<h4>Providing our own implementation of UserDetailsService</h4>
We will write the implementation of method loadUserByUsername.In this method, we will do couple of things
<ul>
 	<li style="list-style-type: none;">
<ol>Find Username in DB, if not found throw an exception</ol>
</li>
 	<li style="list-style-type: none;">
<ol>If the user is found, login user and return the User object of type org.springframework.security.core.userdetails.User, spring will automatically update the Security context for us.</ol>
</li>
</ul>
<pre class="lang:java decode:true">package com.login.security.service.impl;

import java.util.HashSet;
import java.util.Set;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.login.model.UserBean;
import com.login.repository.UserRepository;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {

	@Autowired
	private UserRepository userRepository;
	

	@Override
	@Transactional(readOnly = true)
	public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
		
		UserBean user = userRepository.findByEmail(email);
		 if (user == null) {
	            throw new UsernameNotFoundException("No user found with email: " + email);
	        }
		Set&lt;GrantedAuthority&gt; grantedAuthorities = new HashSet&lt;&gt;();
		grantedAuthorities.add(new SimpleGrantedAuthority("LOGGED_USER"));
		return new User(user.getEmail(), user.getPassword(), grantedAuthorities);
		
		
	}

}
</pre>
<h3>Step 7 - Setting Security context (auto login)</h3>
Once the user is logged in by social providers or by registering a user we need to update security context by setting the authentication

As per the spring API - "Authentication represents the token for an authentication request or for an authenticated principal once the request has been processed by the AuthenticationManager.authenticate(Authentication) method.
Once the request has been authenticated, the Authentication will usually be stored in a thread-local SecurityContext managed by the SecurityContextHolder by the authentication mechanism which is being used. An explicit authentication can be achieved, without using one of Spring Security's authentication mechanisms, by creating an Authentication instance and using the code:

SecurityContextHolder.getContext().setAuthentication(authentication);"

Which is exactly we are going to do in our method.
<pre class="lang:java decode:true">package com.login.autologin;

import java.util.HashSet;
import java.util.Set;

import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import com.login.model.UserBean;

@Service
public class Autologin {

    
    public void setSecuritycontext(UserBean userForm) {
   	Set&lt;GrantedAuthority&gt; grantedAuthorities = new HashSet&lt;&gt;();
   	grantedAuthorities.add(new SimpleGrantedAuthority(userForm.getProvider().toUpperCase()));
   	Authentication authentication = new UsernamePasswordAuthenticationToken(userForm.getEmail(), userForm.getPassword(), grantedAuthorities);
   	SecurityContextHolder.getContext().setAuthentication(authentication);
       }
}
</pre>
<h3>Step 8 - Changing the Login controller</h3>
Since now we have most of the things in place, we need to add the controller so when the registration form is submitted,
<ul>
 	<li>We need to save the user details on DB</li>
 	<li>Update the security context and set the authentication object</li>
 	<li>Redirect user to secure page.</li>
</ul>
Also, since in our Security config, we defined a "/login-error" path, we will handle that too in the same controller.
<pre class="">   
    @Autowired
    private UserRepository userRepository;

    @Autowired
    private BCryptPasswordEncoder bCryptPasswordEncoder;

    @Autowired
    private Autologin autologin;

    @PostMapping("/registration")
    public String registerUser(HttpServletResponse httpServletResponse, Model model, @Valid UserBean userBean, BindingResult bindingResult) {
	if (bindingResult.hasErrors()) {
	    return "registration";
	}
	userBean.setProvider("REGISTRATION");
	// Save the details in DB
	if (StringUtils.isNotEmpty(userBean.getPassword())) {
	    userBean.setPassword(bCryptPasswordEncoder.encode(userBean.getPassword()));
	}
	userRepository.save(userBean);

	autologin.setSecuritycontext(userBean);

	model.addAttribute("loggedInUser", userBean);
	return "secure/user";
    }

    /** If we can't find a user/email combination */
    @RequestMapping("/login-error")
    public String loginError(Model model) {
	model.addAttribute("loginError", true);
	return "login";
    }

</pre>
<h3>Step 9- Modifying the Social Providers</h3>
In previous post we had created the FacebookProvider, GoogleProvider and LinkedInProvider now we need to make some changes in them so they
<ul>
 	<li>Save the user details on DB</li>
 	<li>Update the security context and set the authentication object</li>
 	<li>Redirect the user to secure page.</li>
</ul>
In our class BaseProvider.java, we will add saveUserDetails and autoLoginUser method
<pre class="lang:java decode:true">    

    @Autowired
    private BCryptPasswordEncoder bCryptPasswordEncoder;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    protected Autologin autologin;

    protected void saveUserDetails(UserBean userBean) {
	if (StringUtils.isNotEmpty(userBean.getPassword())) {
	    userBean.setPassword(bCryptPasswordEncoder.encode(userBean.getPassword()));
	}
	userRepository.save(userBean);

    }

    public void autoLoginUser(UserBean userBean) {
	autologin.setSecuritycontext(userBean);
    }
</pre>
In our provider classes(FacebookProvider, GoogleProvider and LinkedInProvider) we just need to add the code to
<code>//Save the details in DB
baseProvider.saveUserDetails(userForm);</code> and <code>//Login the User
baseProvider.autoLoginUser(userForm);</code> and also return back the secure page "secure/user".

You will need to do these changes in all 3 classes(GoogleProvider, FaceBookProvider and LinkedInProvider)
<pre class="lang:java decode:true">	public String getLinkedInUserData(Model model, UserBean userForm) {

		ConnectionRepository connectionRepository = baseProvider.getConnectionRepository();
		if (connectionRepository.findPrimaryConnection(LinkedIn.class) == null) {
			return REDIRECT_LOGIN;
		}
		populateUserDetailsFromLinkedIn(userForm);
		//Save the details in DB
		baseProvider.saveUserDetails(userForm);
		
		//Login the User
		baseProvider.autoLoginUser(userForm);
			
		model.addAttribute("loggedInUser",userForm);
		return "secure/user";
		}

</pre>
<h3>Step 10- A new Controller</h3>
Remeber, we have added in our <code>defaultSuccessUrl("/secure/user")</code> SecurityConfig, well this is the page where we want the user to redirect, once they are authenticated.

Also on user/secure.html, we have defined <code>th:object="${loggedInUser}"</code> this attribute also needs to be initialized once the user is logged in by security config. So the question is how do we initialize the <code>"${loggedInUser}"</code> model attribute. If we don't initialise it we will get an error.
An easy way to fix this problem is to use annotation called @ModelAttribute <code>@ModelAttribute("loggedInUser")</code>. If this annotation has been used all the RequestMapping method in the controller will be called only after the annotated method.

We can define a method where we will get the Authentication object and then use that object to find the user details.
<pre class="lang:java decode:true"> @ModelAttribute("loggedInUser")
    public void secure(Model model) {
	Authentication auth = SecurityContextHolder.getContext().getAuthentication();
	UserBean user = userRepository.findByEmail(auth.getName());
	model.addAttribute("loggedInUser", user);
    }</pre>
Also, we need to define the method for mapping <code>@GetMapping("/secure/user")</code> as shown below. Since we need to initialize model attribute <code>${loggedInUser}</code> only for <code> @GetMapping("/secure/user")</code> we need to define it in a separate controller class.
<pre class="lang:java decode:true">package com.login.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;

import com.login.model.UserBean;
import com.login.repository.UserRepository;

@Controller
public class LoggedInUserController {

    @Autowired
    private UserRepository userRepository;

    @ModelAttribute("loggedInUser")
    public void secure(Model model) {
	Authentication auth = SecurityContextHolder.getContext().getAuthentication();
	UserBean user = userRepository.findByEmail(auth.getName());
	model.addAttribute("loggedInUser", user);
    }

    @GetMapping("/secure/user")
    public String securePage() {
	return "secure/user";
    }

}
</pre>
<h3>Step 11- Updating the properties file</h3>
Since we are using HSQLDB in this example and spring boot will configure most of the things for us, we don't need to do more than defining a couple of properties for initializing the database. Add these properties in application.properties
<pre>spring.jpa.hibernate.ddl-auto=create
spring.jpa.show-sql=true</pre>
<h3>Conclusion</h3>
Spring Social and Spring Security are very flexible and easily customizable for different use cases. They both can be used together to provide a seamless and smooth logging experience for users. The above code is just a step in explaining how both the offerings (Spring Social and Spring Security) can be used in unison.

For readers benefit, above code can be cloned from Github

This is how the project structure looks like

&nbsp;

<img class="aligncenter size-full wp-image-1217" src="http://littlebigextra.com/wp-content/uploads/2017/11/ProjectStructure-1.jpg" alt="" width="300" height="536" />

This is how the screen looks like after user is logged in <img class="aligncenter size-full wp-image-1218" src="http://littlebigextra.com/wp-content/uploads/2017/11/secure-Page.jpg" alt="" width="215" height="199" />